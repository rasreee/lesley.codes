---
title: Build a ⌘K Search Modal (Part 2)
description: 'Part 2 of the tutorial for building a ⌘K Search Modal.'
publishedAt: '2021-12-31'
tags: 'typescript,react,emotion'
image: '/images/cmd-k-menu.png'
---

<Image
  alt={`CMD K Menu`}
  src={`/images/cmd-k-menu.png`}
  width={1440}
  height={960}
  priority
/>

View the [demo](https://react-search-modal-tutorial.vercel.app/).

## Project Setup

Clone or fork the [Github repo](https://github.com/rasreee/cmdk-search-tutorial-skeleton) to follow along:

```bash
git clone https://github.com/rasreee/cmdk-search-tutorial-skeleton.git
```

To run the app, run the following command from the root of the project:

```bash
yarn install && yarn start
```

## Implementation Walkthrough

Review the tutorial instructions [here](http://localhost:3000/blog/build-a-cmd-k-search-modal-1) if you need to, but I'm going to dive straight into the tutorial and explain my solution as best as possible.

Before coding anything, we should take a brief moment to get a better understanding of the architecture we want the implementation to take, keeping in mind that this may change as throughout development and doesn't have to be absolutely perfect from the start. In the real world, the most important thing is to ship features to users as fast as possible - something that can be easy to forget as a Software Engineer.

We can outline a minimal example the of UI flow, specifically the sequence of user inputs and their outputs.

1. The search modal is in its default state (hidden).
2. Bob clicks the "Quick search" button.
3. The search modal is visible, and the top input field is automatically focused.
4. Bob types "doge" into the input field.
5. The search modal briefly shows a loading indicator before displaying the results for the query "doge".
7. Bob clicks the first search hit for "doge".
8. The search modal is hidden, and the app navigates Bob to the search hit's URL.

### Search Hit Data Model

First, let's define a typescript interface that represents the data for a search hit:

```ts
export interface SearchHit {
  /* Unique integer ID */
  id: number
  /* Title for the search hit to present to the user */
  title: string
  /* Pathname of the search hit relative to the client app (i.e. /memes/doge which should take you to https://demo.app/memes/doge ) */
  pathname: string
}
```

### Mocking Search Hit Data using Faker

Now, let's mock search hit data based on this definition. I often use `faker` and `lodash.times` to generate mock data during development instead of using a pre-defined fixture to make things a bit more realistic. Don't forget to install @types/faker and @types/lodash.times for the type definitions if you want your IDE to help you out with autocompletion and whatnot.

Install faker & lodash.times with the following command:
```bash
ya -D faker@5.5.3 @types/faker@5.5.3 lodash.times @types/lodash.times
```

**IMPORTANT** Make sure to keep the faker@5.5.3 versionings because the author pulled a big petty and destroyed the versions after 5.5.3, so yeah.

For now, you can generate any number of mocks; I created a function `generateMockSearchHits` that generates 30 by default:
```ts
export const generateMockSearchHit = (index: number): SearchHitData => ({
  id: index,
  title: faker.lorem.words(3),
  pathname: faker.lorem.slug()
})

export const generateMockSearchHits = (n = 30) => times(n, generateMockSearchHit)
```



## Questions?

If you run into any issues with the tutorial, please feel free to open an issue against the [Github repo](https://github.com/rasreee/cmdk-search-tutorial-skeleton).
